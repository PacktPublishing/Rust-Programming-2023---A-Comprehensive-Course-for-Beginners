{\rtf1\ansi\ansicpg1252\cocoartf2636
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \
/*\
\
What Are HashMaps in Rust\
\
Rust's standard collection library has implementation of some of the most common\
data structures for general purposes. We've seen vectors previously, now let's take a look at HashMaps! \
\
the type HashMap<K, V> stores a mapping of keys of type K to values of type V. \
It does this via a hashing function, which determines how it places these keys and values into memory. \
Many different programming languages support this kind of data structure, \
but often use a different name, such as hash, map, object, hash table, or associative array, just to name a few.\
\
Hash maps are useful for when you want to look up data not by an index, as you can with vectors, \
but by using a key that can be of any type. For example, in a game, you could keep track of each team\'92s \
score in a hash map where each key is a team\'92s name and the values are each team\'92s score. Given a team name, \
you can retrieve its score.\
\
No two entries in a map can have the same key. In short, a map is a lookup table.\
\
1	insert()	\
pub fn insert(&mut self, k: K, v: V) -> Option\
\
Inserts a key/value pair \
\
2	len()	\
pub fn len(&self) -> usize\
\
finds and returns how many elements are in the map\
\
3	get()	\
pub fn get<Q: ?Sized>(&lself, k: &Q) -> Option<&V> where K:Borrow Q:Hash+ Eq\
\
returns a ref to the value of a key\
\
4	iter()	\
pub fn iter(&self) -> Iter<K, V>\
\
Iteration through all key-value pairs \
\
5	contains_key	\
pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\
\
Returns bool whehter a value is true for a specified key\
\
6	remove()	\
pub fn remove_entry<Q: ?Sized>(&mut self, k: &Q) -> Option<(K, V)>\
\
Removes a key from the map\
\
*/\
\
// HashMap Example\
\
use std::collections::HashMap;\
\
fn main() \{\
    \
    let mut accountInfo = HashMap::new();\
    accountInfo.insert("Johnny","Overdraft!");\
    accountInfo.insert("Sally","Good Standing!");\
    //accountInfo.insert("Superman","Insufficient funds!");\
    println!("the size of the accountInfo map is: \{\}", accountInfo.len());\
    \
    let mut barDrinks = HashMap::new();\
    barDrinks.insert("vodka", true);\
    barDrinks.insert("beer", false);\
    barDrinks.insert("whiskey", true,);\
    \
    println!("the size of the barDrinks map before we remove one k/v is: \{\}", barDrinks.len());\
    barDrinks.remove(&"whiskey"); \
    println!("the size of the barDrinks map after we remove one k/v is: \{\}", barDrinks.len());\
    \
\}\
\
/*\
\
Exercise - Build A hash table with Hashmap in Rust \
\
1. Create a new HashMap instance variable barDrinks and using the insert method\
add three new key pair values to your table: vodka, beer, and whiskey as keys and the values\
should be set up so that vodka and whiskey indicate that the bar has some left while beer has all run out. \
\
2. Remove whiskey from the local table. \
\
Good luck and keep those patrons drinking and happy! \
\
*/}