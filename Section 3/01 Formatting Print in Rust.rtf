{\rtf1\ansi\ansicpg1252\cocoartf2636
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh7840\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
\
Printing is handled by a series of macros (\
\
Macros simply allows you to invent your own syntax and write code that writes more code.\
This is called metaprogramming, which allows for syntactic sugars \
that make your code shorter and make it easier to use your libraries. \
You could even create your own DSL (Domain-Specific Language) within rust.\
\
A macro is defined with the pre-processor directive. \
Macros are pre-processed which means that all the macros would be processed before your program compiles. \
However, functions are not preprocessed but compiled.\
\
) defined in std::fmt some of which include:\
\
format!: write formatted text to String\
print!: same as format! but the text is printed to the console (io::stdout).\
println!: same as print! but a newline is appended.\
eprint!: same as print! but the text is printed to the standard error (io::stderr).\
eprintln!: same as eprint! but a newline is appended.\
\
*/\
\
fn main() \{\
    \
    // in general, \{\} will be automatically replaced with any arguments\
    // and stringified\
    \
    println!("\{\} years old", 36);\
    \
    // named arguments also work\
    \
    println!("\{user1\}\{action\}\{user2\}",\
            user1="Mary Lewis",\
            user2="Jon Wick",\
            action=" karate kicked ");\
            \
    \
// Exercise: Within the function main add a println macro which takes two arguments, \
//x and y and stringifies them where x equals "hello " and \
// y equals "my friend".\
\
    println!("\{x\}, \{y\}",\
    x="hello",\
    y="my friend")\
            \
\}\
   \
}